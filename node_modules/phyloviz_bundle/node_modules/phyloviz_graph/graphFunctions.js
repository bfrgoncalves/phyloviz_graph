function loadGraphFunctions(){

	var VivaGraph = require('vivagraphjs');
	var renderFunc = require('./pieNodeWebGl.js');
	var startMultiSelect = require('./multiSelection.js');
	var renderFunctions = renderFunc.graphRenderingFunctions();

	function restoreLinkSearch(graphObject){

		var toRemove = graphObject.toRemove;
		var graphics = graphObject.graphics;
		var nodesToCheckLinks = graphObject.nodesToCheckLinks;
		var renderer = graphObject.renderer;

		if (toRemove != ""){
			var nodeUI = graphics.getNodeUI(toRemove.id);
			nodeUI.colorIndexes = nodeUI.backupColor;

		}
		for (i in nodesToCheckLinks){
			var nodeUI = graphics.getNodeUI(nodesToCheckLinks[i].id);
			nodeUI.colorIndexes = nodeUI.backupColor; 
		}

		if(graphObject.isLayoutPaused){
	        renderer.resume();
	        setTimeout(function(){ renderer.pause();}, 5);
	      }
	}

	return {
		init: function(graphObject){

			var graph = graphObject.graphInput;
			var graphGL = graphObject.graphGL;

			var maxLinkValue = 0;
			var countAddedNodes = 0;
			
			for (i in graph.nodes){
		        graph.nodes[i].idGL = countAddedNodes;
		        graphGL.addNode(graph.nodes[i].key, graph.nodes[i]);
		        countAddedNodes++;
		    }

		    for (j in graph.links){
		        if (maxLinkValue < graph.links[j].value) maxLinkValue = graph.links[j].value;
			    graphGL.addLink(graph.links[j].source, graph.links[j].target, { connectionStrength: graph.links[j].value , value: graph.links[j].value, color: "#000"});
		    }

		    var treeLinks = {};

		    graphGL.forEachLink(function(link) { treeLinks[link.id] = true; });

		    maxLinkValue += 1;

		    graphObject.maxLinkValue = maxLinkValue;

		    graphObject.treeLinks = treeLinks;
		    graphObject.isLogScale = false;

		    graphObject.assignQuadrant = renderFunc.assignQuadrant;
		    graphObject.getDataPercentage = renderFunc.getDataPercentage;
		},

		initLayout: function(graphObject){

			var idealSpringLength = 1;
			var graphGL = graphObject.graphGL;

			graphObject.layout = VivaGraph.Graph.Layout.forceDirected(graphGL, {
						    	    springLength : idealSpringLength,
						    	    springCoeff : 0.0001,
						    	    dragCoeff : 0.01,
						    	    gravity : -10,
						    	    theta: 0.8,

							          // This is the main part of this example. We are telling force directed
							          // layout, that we want to change length of each physical spring
							          // by overriding `springTransform` method:
							          springTransform: function (link, spring) {
							            spring.length = idealSpringLength * link.data.connectionStrength;
							          }
						      	});
		},

		initGraphics: function(graphObject){

			var graphicsOptions = {
	          clearColor: true, // we want to avoid rendering artifacts
	          clearColorValue: { // use black color to erase background
	            r: 255,
	            g: 255,
	            b: 255,
	            a: 1
	          }
	        };

			graphObject.graphics = VivaGraph.Graph.View.webglGraphics(graphicsOptions);
			var graphics = graphObject.graphics;

			var circleNode = renderFunctions.buildCircleNodeShader();
	        graphics.setNodeProgram(circleNode);

	        var DefaultnodeSize = graphObject.DefaultnodeSize;
	        var nodeColor = graphObject.nodeColor;


	        graphics.node(function (node) {
	          //console.log(node);
	          if (node.id.search('TransitionNode') > -1) sizeToUse = 5;
	          else sizeToUse = DefaultnodeSize+node.data.isolates.length;
	          return new renderFunctions.WebglCircle(sizeToUse, nodeColor, [1], [nodeColor], null);
	        });

	        graphics.link(function(link) {
	          return VivaGraph.Graph.View.webglLine(link.data.color, link.id);
	        });

		},

		initRenderer: function(graphObject){

			var graphGL = graphObject.graphGL;

			graphObject.renderer = VivaGraph.Graph.View.renderer(graphGL,
              {
                  container  : document.getElementById( graphObject.container ),
                  layout : graphObject.layout,
                  graphics : graphObject.graphics

              });

        	graphObject.renderer.run();

		},

		setPositions: function(graphObject){

			var graph = graphObject.graphInput;
			var layout = graphObject.layout;

			//console.log(graph);

			if (Object.keys(graph.positions).length > 0){
		        for (nodeLocation in graph.positions.nodes[0]){
		          var nodeX = graph.positions.nodes[0][nodeLocation][0].x;
		          var nodeY = graph.positions.nodes[0][nodeLocation][0].y;
		          layout.setNodePosition(nodeLocation, nodeX, nodeY);
		        }
		      }
		},

		precompute: function myself(graphObject, iterations, callback) { //define name inside function to be able to call it from inside

			var layout = graphObject.layout;
	        // let's run 10 iterations per event loop cycle:
	        var i = 0;
	        while (iterations > 0 && i < 1) {
	          layout.step();
	          iterations--;
	          i++;
	        }
	        //$('#processingElement').children().remove();

	        if (iterations > 0) {
	          setTimeout(function () {
	              myself(graphObject,iterations, callback);
	          }, 0); // keep going in next even cycle
	        } else {
	          // we are done!
	          //$('#processingElement').children().remove();

    		  layout.simulator.dragCoeff(30 * 0.0001);
	          
	          callback();
	        }
        }	

	}
}

module.exports = loadGraphFunctions;

